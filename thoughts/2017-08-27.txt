函数重载说到底是一种抽象工具，它使库用户（调用者）对于逻辑上等价或近似的功能能够使用统一的函数（接口）名，而不再关心对于特定类型应该使用哪种实现。从调用者的观点，他们不再关心参数的类型问题，因为函数总是像逻辑上期待的那样运行，行为和类型解耦。

为什么不能用变长参数表在C中实现重载？

因为重载能在获得类型信息（本质是形参的类型和顺序作为函数signature的一部分，链接器根据编译器留下来的signature，实质上链接的是不同的函数），而变长参数表不能。

无法在C/C++中的变长函数表中获得运行时的类型，因为C/C++的变量系统的并不存储变量的类型，而是单纯的存储起始地址。

如果编译时和运行时都有类型信息，那么——比如如果程序员在代码里将类型A强转为类型B，编译时是否该检查这种转换是否合法？

此处产生了两种分歧

	1. 认为编译时的信息应该作为编译是否成功的条件，即编译器应该注意到类型的不匹配并拒绝编译，将错误处理放在编译阶段（比如不合法的基本类型强转，或者非父子类的强转）
	2. 认为编译时对于类型的处理无关紧要，将关于类型的错误推迟到运行时处理（注意这是很多脚本语言的思想，而脚本语言根本不存在正式的编译过程）

前者的代表是Java，虽然Java也有运行时的类异常，比如ClassCastException，但这仅是在编译时的上下文不足以提供需要的类型信息时的策略（比如函数有一个Object形参，并在内部将其cast为其他类的实例，此时的异常处理只能推迟到运行时，因为编译器不可能走一遍每个调用过程来决定是否合法——说白了这种问题是多态思想中的upcasting带来的，函数声明一个Object形参，而主调传了一个Integer实参，这是合法的——这是多态的代价。

后者的代表是各种脚本语言如Python，特征是根本没有正式的编译过程，“编译时”的类型处理也就无从谈起。不仅仅是类型错误，所有的异常都会推迟到运行时抛出，直到某条语句正式运行前，只检查该语句中最基本的lexical & syntactic error。

